#### [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)

éš¾åº¦ç®€å•, ï¼ˆ<font color="red">æ¢¦å¼€å§‹çš„åœ°æ–¹hhhhğŸ˜‚</font>ï¼‰

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªç›®æ ‡å€¼ `target`ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ **ä¸¤ä¸ª** æ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚

ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚

 

**ç¤ºä¾‹:**

```
ç»™å®š nums = [2, 7, 11, 15], target = 9

å› ä¸º nums[0] + nums[1] = 2 + 7 = 9
æ‰€ä»¥è¿”å› [0, 1]
```

**æ€è·¯ï¼š**

â€‹	å»ºç«‹å“ˆå¸Œå­—å…¸

**ä»£ç ï¼š**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic={}
        for i, num in enumerate(nums):
            dic[num] = i

        for i, number in enumerate (nums):
            remain = target - number
            if remain in dic and dic[remain]!=i:
                return [i, dic[remain]]
```



#### [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode-cn.com/problems/add-two-numbers/)

éš¾åº¦ä¸­ç­‰

ç»™å‡ºä¸¤ä¸ª **éç©º** çš„é“¾è¡¨ç”¨æ¥è¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªçš„ä½æ•°æ˜¯æŒ‰ç…§ **é€†åº** çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ **ä¸€ä½** æ•°å­—ã€‚

å¦‚æœï¼Œæˆ‘ä»¬å°†è¿™ä¸¤ä¸ªæ•°ç›¸åŠ èµ·æ¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨æ¥è¡¨ç¤ºå®ƒä»¬çš„å’Œã€‚

æ‚¨å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥ï¼š(2 -> 4 -> 3) + (5 -> 6 -> 4)
è¾“å‡ºï¼š7 -> 0 -> 8
åŸå› ï¼š342 + 465 = 807
```



**æ€è·¯ï¼š**

â€‹	è®¾ç½®ä¸¤ä¸ªdummy node

**ä»£ç :**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        p=q=ListNode(None)
        s=0
        while (l1 or l2 or s):
            l1val = l1.val if l1 else 0 
            l2val = l2.val if l2 else 0
            s += l1val+l2val
            p.next = ListNode(s%10)
            p = p.next
            s=s//10
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next

        return q.next  
```



#### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

éš¾åº¦ä¸­ç­‰

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: "abcabcbb"
è¾“å‡º: 3 
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: "bbbbb"
è¾“å‡º: 1
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "b"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 1ã€‚
```

**ç¤ºä¾‹ 3:**

```
è¾“å…¥: "pwwkew"
è¾“å‡º: 3
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "wke"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
     è¯·æ³¨æ„ï¼Œä½ çš„ç­”æ¡ˆå¿…é¡»æ˜¯ å­ä¸² çš„é•¿åº¦ï¼Œ"pwke" æ˜¯ä¸€ä¸ªå­åºåˆ—ï¼Œä¸æ˜¯å­ä¸²ã€‚
```

**æ€è·¯ï¼š**

â€‹	ç”¨ä¸€ä¸ªå­—å…¸ `dic`è®°å½•å½“å‰å­—ç¬¦æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œ`last` è¡¨ç¤ºä¸å«é‡å¤çš„å¼€å¤´ï¼Œæ³¨æ„ `last` ä¸èƒ½åé€€ï¼Œæ¯”å¦‚ `'abba'`ï¼š

â€‹	å› æ­¤ `last = max(last, dic[char]+1)â€‹`

**ä»£ç ï¼š**

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic={}
        last = 0
        ans = 0
        for i, char in enumerate(s):
            if char not in dic:
                dic[char] = i
            else:
                last = max(last, dic[char]+1)
                dic[char] = i
            ans = max(ans, i-last+1)
        return ans
```



#### [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

éš¾åº¦å›°éš¾

ç»™å®šä¸¤ä¸ªå¤§å°ä¸º m å’Œ n çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„ `nums1` å’Œ `nums2`ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°ã€‚

**è¿›é˜¶ï¼š**ä½ èƒ½è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º `O(log (m+n))` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2]
è¾“å‡ºï¼š2.00000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums1 = [1,2], nums2 = [3,4]
è¾“å‡ºï¼š2.50000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3,4] ï¼Œä¸­ä½æ•° (2 + 3) / 2 = 2.5
```

**ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼šnums1 = [0,0], nums2 = [0,0]
è¾“å‡ºï¼š0.00000
```

**ç¤ºä¾‹ 4ï¼š**

```
è¾“å…¥ï¼šnums1 = [], nums2 = [1]
è¾“å‡ºï¼š1.00000
```

**ç¤ºä¾‹ 5ï¼š**

```
è¾“å…¥ï¼šnums1 = [2], nums2 = []
è¾“å‡ºï¼š2.00000
```

**æ€è·¯ï¼š**

	1. å°†ä¸¤ä¸ªæ•°ç»„åˆå¹¶ä¸ºæœ‰åºæ•°ç»„ï¼Œå†æ±‚ä¸­ä½æ•°ï¼Œä½†è¿™æ ·æ˜¯`O(m+n)`ï¼Œä½†æ­¤é¢˜ä¹Ÿèƒ½è¿‡ã€‚
 	2. å¦‚æœè¦æ±‚æ˜¯ `O(log (m+n))`ï¼Œ çœ‹åˆ°`log`, æƒ³åˆ°äºŒåˆ†æ³•ï¼Œæ­¤æ³•éœ€è¦æŒæ¡ã€‚

**ä»£ç ï¼š**

æ€è·¯1ï¼š

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        i, j = 0, 0
        l1, l2 = len(nums1), len(nums2)
        num = []
        while(i<l1 and j<l2):
            if nums1[i]<nums2[j]:
                num.append(nums1[i])
                i+=1
            else:
                num.append(nums2[j])
                j+=1
        if i<l1:
            num.extend(nums1[i-l1:])
        else:
            num.extend(nums2[j-l2:])
        l=l1+l2
        if l % 2==1:
            return num[l//2]
        else:
            return (num[l//2]+num[l//2-1])/2

```

æ€è·¯2ï¼š

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def findk(arr1,arr2,k):
            l1, l2 = len(arr1), len(arr2)
            if l1>l2:
                return findk(arr2, arr1, k)
            if not arr1:
                return arr2[k-1]
            if k==1:
                return min(arr1[0],arr2[0])
            i = min(l1, k//2)-1
            j = min(l2,k//2)-1

            if arr1[i]<arr2[j]:
                return findk(arr1[i+1:], arr2, k-i-1)
            else:
                return findk(arr1,arr2[j+1:],k-j-1)
        left = (len(nums1)+len(nums2)+1)//2
        right = (len(nums1)+len(nums2)+2)//2
        return (findk(nums1,nums2,left)+findk(nums1,nums2,right))/2

```



#### [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

éš¾åº¦ä¸­ç­‰

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ `s` çš„æœ€å¤§é•¿åº¦ä¸º 1000ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥: "babad"
è¾“å‡º: "bab"
æ³¨æ„: "aba" ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: "cbbd"
è¾“å‡º: "bb"
```

**æ€è·¯ï¼š**

â€‹	ä¸­å¿ƒæ‰©å±•æ³•ï¼Œå¯¹äºæ¯ä¸€ä¸ªå½“å‰çš„`s[i]`ï¼Œéƒ½æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ä»¥å½“å‰`i`ä¸ºä¸­å¿ƒï¼Œé•¿åº¦ä¸ºå¥‡æ•°çš„å­—ç¬¦ä¸²ï¼›ä¸€ç§æ˜¯`s[i]=s[i+1]`, ä»¥è¿™ä¸¤ä¸ªä¸ºä¸­å¿ƒï¼Œé•¿åº¦ä¸ºå¶æ•°çš„å­—ç¬¦ä¸²ï¼Œæ¯”è¾ƒæœ€é•¿å³å¯ã€‚

**ä»£ç ï¼š**

```python
class Solution:
    def longestPalindrome(self,s) -> str:
        def center_spread(s,length,left,right):
            while(left>=0 and right<length and s[left]==s[right]):
                left-=1
                right+=1
            return s[left+1:right], right-left-1

        max_len = 1
        ans = s[0]
        length = len(s)
        for i in range(len(s)):
            ans_odd ,len_odd = center_spread(s,length,i,i)
            ans_even, len_even = center_spread(s, length, i, i+1)
            cur_len_max = max(len_odd, len_even)
            cur_ans = ans_odd if len_odd>len_even else ans_even
            #print(cur_ans,len_odd,len_even)
            if cur_len_max > max_len:
                max_len = cur_len_max
                ans = cur_ans
        return ans
```

