#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

难度简单

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

**示例 1:**

```
输入: haystack = "hello", needle = "ll"
输出: 2
```

**示例 2:**

```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

**说明:**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

**思路：**

	1. 这道题虽说是简单题，但是有不同的方法理解，难度自然也不同。先上一种最简单的滑动窗口挨个比较即可。
 	2. 双指针法，两个指针分别指向`haystack`和`needle`，只有当他们的第一个字母相同时候，再往后面比较，长度加1，长度等于`needle`长度时候返回，如果不等，指向`haystack`的指针回到上个开始位置的下一个，指向`needle`的指针归零。

**代码:**

方法一:

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        l,n = len(needle), len(haystack)
        for i in range(n-l+1):
            if needle==haystack[i:i+l]:
                return i
        return -1
```

方法二：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not needle:
            return 0

        l,n = len(needle), len(haystack)
        ph, pn=0, 0
        cur = 0
        while(ph < n-l+1):    
            while(haystack[ph] == needle[pn] and ph<n and pn<l):
                ph+=1
                pn+=1
                cur+=1
                if cur==l:
                    return ph-cur
            ph = ph-cur+1
            pn=0
            cur = 0
        return -1
```



#### [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

难度中等

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`

 

**示例 1:**

```
输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
```

**示例 2:**

```
输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2
```

 

**提示：**

- 被除数和除数均为 32 位有符号整数。
- 除数不为 0。
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。

**思路:**

​	最直观的就是用减法模拟了，但是如果暴力用减法会超时， 比如一个很大很大的数除以1，每次都减去1，肯定超时。

因此，需要针对这种方法进行优化，每次除数乘2，（注意：这里用`<<`位运算代替乘法）。

**代码:**

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        if divisor == 0 or dividend == 0:
            return 0
        if divisor == dividend:
            return 1

        result = 0
        positive = True if (dividend > 0 and divisor > 0) or (dividend < 0 and divisor < 0) else False

        if divisor == 1 or divisor == -1:
            result = abs(dividend)
            return min(result, 2147483647) if positive else -max(result, -2147483648)
        
        dividend = abs(dividend)
        divisor = abs(divisor)
        while dividend >= divisor:
            tmp, i = divisor, 1
            while dividend >= tmp:
                dividend -= tmp
                result += i
                i <<= 1
                tmp <<= 1

        if positive:
            return result
        else:
            return -result
```



